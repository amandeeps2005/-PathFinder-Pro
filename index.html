<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PathFinder Pro - Gamified Algorithm Visualizer</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <i class="fas fa-route"></i>
                <h1>PathFinder Pro</h1>
            </div>
            <nav class="nav-tabs">
                <button class="nav-tab active" data-tab="visualizer">
                    <i class="fas fa-play"></i> Visualizer
                </button>
                <button class="nav-tab" data-tab="theory">
                    <i class="fas fa-book"></i> Theory
                </button>

            </nav>
            <div class="score-display">

                <div class="score-item">
                    <i class="fas fa-clock"></i>
                    <span id="timer">00:00</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Visualizer Tab -->
            <div class="tab-content active" id="visualizer-tab">
                <div class="visualizer-container">
                    <!-- Control Panel -->
                    <div class="control-panel">
                        <div class="control-group">
                            <h3><i class="fas fa-cog"></i> Algorithm</h3>
                            <select id="algorithm-select" class="control-select">
                                <option value="dijkstra">Dijkstra's Algorithm</option>
                                <option value="astar">A* Search</option>
                                <option value="bfs">Breadth-First Search</option>
                                <option value="dfs">Depth-First Search</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <h3><i class="fas fa-tachometer-alt"></i> Speed</h3>
                            <input type="range" id="speed-slider" min="1" max="10" value="5" class="control-slider">
                            <span id="speed-value">5x</span>
                        </div>
                        
                        <div class="control-group">
                            <h3><i class="fas fa-gamepad"></i> Game Mode</h3>
                            <select id="game-mode" class="control-select">
                                <option value="free">Free Play</option>
                                <option value="challenge">Challenge Mode</option>
                                <option value="maze">Maze Runner</option>
                                <option value="race">Time Race</option>
                            </select>
                        </div>

                        <div class="button-group">
                            <button id="start-btn" class="btn btn-primary">
                                <i class="fas fa-play"></i> Start
                            </button>
                            <button id="pause-btn" class="btn btn-secondary">
                                <i class="fas fa-pause"></i> Pause
                            </button>
                            <button id="reset-btn" class="btn btn-danger">
                                <i class="fas fa-redo"></i> Reset
                            </button>
                            <button id="generate-maze-btn" class="btn btn-success">
                                <i class="fas fa-random"></i> Generate Maze
                            </button>
                        </div>


                    </div>

                    <!-- Grid Container -->
                    <div class="grid-container">
                        <div class="grid-header">
                            <h2>Interactive Grid</h2>
                            <div class="grid-legend">
                                <div class="legend-item">
                                    <div class="legend-color start"></div>
                                    <span>Start</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color end"></div>
                                    <span>End</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color wall"></div>
                                    <span>Wall</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color visited"></div>
                                    <span>Visited</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color path"></div>
                                    <span>Path</span>
                                </div>
                            </div>
                        </div>
                        <canvas id="grid-canvas" width="800" height="600"></canvas>
                        <div class="grid-instructions">
                            <p><i class="fas fa-mouse-pointer"></i> Click to place start/end points or draw walls</p>
                            <p><i class="fas fa-keyboard"></i> Press SPACE to start visualization</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Theory Tab -->
            <div class="tab-content" id="theory-tab">
                <div class="theory-container">
                    <div class="theory-sidebar">
                        <h3>Algorithms</h3>
                        <ul class="theory-nav">
                            <li><a href="#dijkstra-theory" class="theory-link active" data-target="dijkstra-theory">Dijkstra's Algorithm</a></li>
                            <li><a href="#astar-theory" class="theory-link" data-target="astar-theory">A* Search</a></li>
                            <li><a href="#bfs-theory" class="theory-link" data-target="bfs-theory">Breadth-First Search</a></li>
                            <li><a href="#dfs-theory" class="theory-link" data-target="dfs-theory">Depth-First Search</a></li>
                        </ul>
                    </div>
                    <div class="theory-content">
                        <!-- Dijkstra's Algorithm Section -->
                        <div class="theory-section active" id="dijkstra-theory">
                            <h2>Dijkstra's Algorithm</h2>
                            <div class="theory-card">
                                <h3>Overview</h3>
                                <p>Dijkstra's Algorithm is a classic and influential algorithm for finding the shortest paths between nodes in a weighted graph. It is guaranteed to find the shortest path from a starting node to all other nodes, provided that the weights of the edges are non-negative. It operates by exploring outwards from the start node, always choosing the next closest node to visit.</p>
                            </div>
                            <div class="theory-card">
                                <h3>How It Works</h3>
                                <ol>
                                    <li><strong>Initialization:</strong> Set the distance to the starting node as 0 and all other nodes to infinity. All nodes are marked as unvisited. A priority queue is created to store nodes to visit, prioritized by distance.</li>
                                    <li><strong>Exploration:</strong> While there are unvisited nodes, select the one with the smallest known distance.</li>
                                    <li><strong>Update Neighbors:</strong> For the current node, consider all of its unvisited neighbors. Calculate the distance from the start node to each neighbor through the current node.</li>
                                    <li><strong>Path Relaxation:</strong> If the newly calculated distance to a neighbor is shorter than its previously known distance, update it and add the neighbor to the priority queue.</li>
                                    <li><strong>Completion:</strong> The algorithm finishes when the destination node is reached or when the smallest distance in the priority queue is infinity, meaning no path exists.</li>
                                </ol>
                            </div>
                            <div class="theory-card">
                                <h3>Pseudocode</h3>
                                <pre><code>function Dijkstra(Graph, source):
  for each vertex v in Graph:
    dist[v] = infinity
    prev[v] = undefined
  dist[source] = 0
  Q = the set of all nodes in Graph

  while Q is not empty:
    u = vertex in Q with min dist[u]
    remove u from Q
    for each neighbor v of u:
      alt = dist[u] + length(u, v)
      if alt < dist[v]:
        dist[v] = alt
        prev[v] = u
return dist[], prev[]</code></pre>
                            </div>
                            <div class="theory-card">
                                <h3>Implementation</h3>
                                <div class="code-tabs-container">
                                    <div class="code-tab-buttons">
                                        <button class="code-tab-button active" data-lang="java">Java</button>
                                        <button class="code-tab-button" data-lang="python">Python</button>
                                        <button class="code-tab-button" data-lang="cpp">C++</button>
                                    </div>
                                    <div class="code-snippet-container">
                                        <pre class="code-snippet active" data-lang="java"><code class="language-java">public class Dijkstra {
    public void computePaths(Node source) {
        source.setDistance(0);
        PriorityQueue<Node> queue = new PriorityQueue<>();
        queue.add(source);

        while (!queue.isEmpty()) {
            Node u = queue.poll();

            for (Edge e : u.getAdjacencies()) {
                Node v = e.getTarget();
                double weight = e.getWeight();
                double distanceThroughU = u.getDistance() + weight;

                if (distanceThroughU < v.getDistance()) {
                    queue.remove(v);
                    v.setDistance(distanceThroughU);
                    v.setPrevious(u);
                    queue.add(v);
                }
            }
        }
    }
}</code></pre>
                                        <pre class="code-snippet" data-lang="python"><code class="language-python">import heapq

def dijkstra(graph, start_node):
    distances = {node: float('infinity') for node in graph}
    distances[start_node] = 0
    priority_queue = [(0, start_node)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)

        if current_distance > distances[current_node]:
            continue

        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances</code></pre>
                                        <pre class="code-snippet" data-lang="cpp"><code class="language-cpp">#include <iostream>
#include <vector>
#include <queue>
#include <limits>

using namespace std;

const int INF = numeric_limits<int>::max();

void dijkstra(const vector<vector<pair<int, int>>>& adj, int start_node) {
    int n = adj.size();
    vector<int> dist(n, INF);
    dist[start_node] = 0;

    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    pq.push({0, start_node});

    while (!pq.empty()) {
        int u = pq.top().second;
        int d = pq.top().first;
        pq.pop();

        if (d > dist[u]) {
            continue;
        }

        for (auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- A* Search Algorithm Section -->
                        <div class="theory-section" id="astar-theory">
                            <h2>A* Search Algorithm</h2>
                            <div class="theory-card">
                                <h3>Overview</h3>
                                <p>A* (pronounced "A-star") is a powerful and widely used pathfinding algorithm that intelligently combines the strengths of Dijkstra's Algorithm and Greedy Best-First Search. It finds the shortest path by considering both the actual distance from the start (cost) and an estimated distance to the goal (heuristic).</p>
                            </div>
                            <div class="theory-card">
                                <h3>The Formula: f(n) = g(n) + h(n)</h3>
                                <p>A* prioritizes which node to explore next based on this formula:</p>
                                <ul>
                                    <li><strong>g(n):</strong> The actual cost from the start node to the current node 'n'. This is the known part of the path.</li>
                                    <li><strong>h(n):</strong> The heuristic, or estimated cost, from node 'n' to the goal. This is an educated guess that must be admissible (never overestimates the true cost).</li>
                                    <li><strong>f(n):</strong> The total estimated cost of the path. A* always expands the node with the lowest f(n) value.</li>
                                </ul>
                            </div>
                            <div class="theory-card">
                                <h3>Pseudocode</h3>
                                <pre><code>function A*(start, goal):
  openSet = {start}
  cameFrom = an empty map
  gScore[start] = 0
  fScore[start] = heuristic(start, goal)

  while openSet is not empty:
    current = the node in openSet with the lowest fScore[] value
    if current == goal:
      return reconstruct_path(cameFrom, current)

    remove current from openSet
    for each neighbor of current:
      tentative_gScore = gScore[current] + dist(current, neighbor)
      if tentative_gScore < gScore[neighbor]:
        cameFrom[neighbor] = current
        gScore[neighbor] = tentative_gScore
        fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goal)
        if neighbor not in openSet:
          add neighbor to openSet

  return failure</code></pre>
                            </div>
                            <div class="theory-card">
                                <h3>Implementation</h3>
                                <div class="code-tabs-container">
                                    <div class="code-tab-buttons">
                                        <button class="code-tab-button active" data-lang="java">Java</button>
                                        <button class="code-tab-button" data-lang="python">Python</button>
                                        <button class="code-tab-button" data-lang="cpp">C++</button>
                                    </div>
                                    <div class="code-snippet-container">
                                        <pre class="code-snippet active" data-lang="java"><code class="language-java">public class AStar {
    public List<Node> findPath(Node start, Node goal) {
        PriorityQueue<Node> openSet = new PriorityQueue<>();
        Set<Node> closedSet = new HashSet<>();
        start.setGScore(0);
        start.setFScore(heuristic(start, goal));
        openSet.add(start);

        while (!openSet.isEmpty()) {
            Node current = openSet.poll();
            if (current.equals(goal)) {
                return reconstructPath(current);
            }

            closedSet.add(current);
            for (Edge edge : current.getAdjacencies()) {
                Node neighbor = edge.getTarget();
                if (closedSet.contains(neighbor)) continue;

                double tentativeGScore = current.getGScore() + edge.getWeight();
                if (tentativeGScore < neighbor.getGScore()) {
                    neighbor.setPrevious(current);
                    neighbor.setGScore(tentativeGScore);
                    neighbor.setFScore(neighbor.getGScore() + heuristic(neighbor, goal));
                    if (!openSet.contains(neighbor)) {
                        openSet.add(neighbor);
                    }
                }
            }
        }
        return null; // No path found
    }
}</code></pre>
                                        <pre class="code-snippet" data-lang="python"><code class="language-python">import heapq

def a_star(graph, start, goal, heuristic):
    open_set = [(heuristic(start, goal), start)]
    came_from = {}
    g_score = {node: float('inf') for node in graph}
    g_score[start] = 0

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == goal:
            return reconstruct_path(came_from, current)

        for neighbor, weight in graph[current].items():
            tentative_g_score = g_score[current] + weight
            if tentative_g_score < g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score = tentative_g_score + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f_score, neighbor))
    
    return None # No path found</code></pre>
                                        <pre class="code-snippet" data-lang="cpp"><code class="language-cpp">#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
#include <map>

using namespace std;

struct Node {
    int id;
    double g_score;
    double f_score;

    bool operator>(const Node& other) const {
        return f_score > other.f_score;
    }
};

double heuristic(int a, int b) {
    // Example heuristic (Euclidean distance)
    return 0; 
}

vector<int> a_star(const vector<vector<pair<int, int>>>& adj, int start, int goal) {
    int n = adj.size();
    priority_queue<Node, vector<Node>, greater<Node>> open_set;
    map<int, double> g_score;
    map<int, int> came_from;

    for (int i = 0; i < n; ++i) {
        g_score[i] = numeric_limits<double>::infinity();
    }
    g_score[start] = 0;

    open_set.push({start, 0, heuristic(start, goal)});

    while (!open_set.empty()) {
        Node current = open_set.top();
        open_set.pop();

        if (current.id == goal) {
            // Reconstruct path
            vector<int> path;
            int temp = current.id;
            while (came_from.count(temp)) {
                path.push_back(temp);
                temp = came_from[temp];
            }
            path.push_back(start);
            reverse(path.begin(), path.end());
            return path;
        }

        for (auto& edge : adj[current.id]) {
            int neighbor = edge.first;
            double weight = edge.second;
            double tentative_g_score = g_score[current.id] + weight;

            if (tentative_g_score < g_score[neighbor]) {
                came_from[neighbor] = current.id;
                g_score[neighbor] = tentative_g_score;
                double f_score = g_score[neighbor] + heuristic(neighbor, goal);
                open_set.push({neighbor, g_score[neighbor], f_score});
            }
        }
    }
    return {}; // No path found
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Breadth-First Search (BFS) Section -->
                        <div class="theory-section" id="bfs-theory">
                            <h2>Breadth-First Search (BFS)</h2>
                            <div class="theory-card">
                                <h3>Overview</h3>
                                <p>Breadth-First Search is an algorithm for traversing or searching tree or graph data structures. It starts at a selected node (the 'source') and explores all of its neighbors at the present depth prior to moving on to the nodes at the next depth level. It is guaranteed to find the shortest path in terms of the number of edges in an unweighted graph.</p>
                            </div>
                            <div class="theory-card">
                                <h3>How It Works</h3>
                                <ol>
                                    <li><strong>Queue-Based:</strong> BFS uses a queue data structure (First-In, First-Out) to manage which node to visit next.</li>
                                    <li><strong>Initialization:</strong> Add the start node to the queue and mark it as visited.</li>
                                    <li><strong>Level-by-Level Exploration:</strong> While the queue is not empty, remove the first node from the queue.</li>
                                    <li><strong>Process Neighbors:</strong> For the removed node, find all of its unvisited neighbors. Mark them as visited and add them to the back of the queue.</li>
                                    <li><strong>Completion:</strong> The algorithm ends when the goal node is found or the queue becomes empty.</li>
                                </ol>
                            </div>
                            <div class="theory-card">
                                <h3>Pseudocode</h3>
                                <pre><code>procedure BFS(G, start_v):
  let Q be a queue
  Q.enqueue(start_v)
  let discovered be a set
  discovered.add(start_v)

  while Q is not empty:
    v = Q.dequeue()
    if v is the goal:
      return v
    for each edge from v to w in G.adjacentEdges(v):
      if w is not in discovered:
        discovered.add(w)
        Q.enqueue(w)
  return None</code></pre>
                            </div>
                            <div class="theory-card">
                                <h3>Implementation</h3>
                                <div class="code-tabs-container">
                                    <div class="code-tab-buttons">
                                        <button class="code-tab-button active" data-lang="java">Java</button>
                                        <button class="code-tab-button" data-lang="python">Python</button>
                                        <button class="code-tab-button" data-lang="cpp">C++</button>
                                    </div>
                                    <div class="code-snippet-container">
                                        <pre class="code-snippet active" data-lang="java"><code class="language-java">public void bfs(Node start) {
    Queue<Node> queue = new LinkedList<>();
    Set<Node> visited = new HashSet<>();
    queue.add(start);
    visited.add(start);

    while (!queue.isEmpty()) {
        Node current = queue.poll();
        // Process current node

        for (Node neighbor : current.getNeighbors()) {
            if (!visited.contains(neighbor)) {
                visited.add(neighbor);
                queue.add(neighbor);
            }
        }
    }
}</code></pre>
                                        <pre class="code-snippet" data-lang="python"><code class="language-python">from collections import deque

def bfs(graph, start_node):
    visited = set()
    queue = deque([start_node])
    visited.add(start_node)

    while queue:
        node = queue.popleft()
        // Process node

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)</code></pre>
                                        <pre class="code-snippet" data-lang="cpp"><code class="language-cpp">#include <iostream>
#include <vector>
#include <queue>
#include <set>

using namespace std;

void bfs(const vector<vector<int>>& adj, int start_node) {
    int n = adj.size();
    queue<int> q;
    set<int> visited;

    q.push(start_node);
    visited.insert(start_node);

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        // Process node u

        for (int v : adj[u]) {
            if (visited.find(v) == visited.end()) {
                visited.insert(v);
                q.push(v);
            }
        }
    }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>


                        <div class="theory-section" id="dfs-theory">
                            <h2>Depth-First Search (DFS)</h2>
                            <div class="theory-card">
                                <h3>Overview</h3>
                                <p>Depth-First Search explores as far as possible along each branch before backtracking. Unlike BFS, it does not explore level by level. It uses a stack (Last-In, First-Out) or recursion to keep track of nodes. DFS does not guarantee the shortest path but is very useful for other tasks like maze generation or topological sorting.</p>
                            </div>
                            <div class="theory-card">
                                <h3>How It Works</h3>
                                <ol>
                                    <li><strong>Stack-Based:</strong> DFS uses a stack data structure to manage which node to visit next.</li>
                                    <li><strong>Initialization:</strong> Push the start node onto the stack.</li>
                                    <li><strong>Deep Exploration:</strong> While the stack is not empty, pop a node from the top of the stack.</li>
                                    <li><strong>Visit and Push Neighbors:</strong> If the node has not been visited, mark it as visited and push all of its unvisited neighbors onto the stack. This ensures the most recently added neighbor is explored next.</li>
                                    <li><strong>Backtracking:</strong> When a path dead-ends, the algorithm naturally backtracks by popping the next node from the stack, which takes it to a previous branching point.</li>
                                </ol>
                            </div>
                            <div class="theory-card">
                                <h3>Pseudocode</h3>
                                <pre><code>procedure DFS(G, v):
  let S be a stack
  S.push(v)
  while S is not empty:
    v = S.pop()
    if v is not labeled as discovered:
      label v as discovered
      for all edges from v to w in G.adjacentEdges(v):
        S.push(w)</code></pre>
                            </div>
                            <div class="theory-card">
                                <h3>Implementation</h3>
                                <div class="code-tabs-container">
                                    <div class="code-tab-buttons">
                                        <button class="code-tab-button active" data-lang="java">Java</button>
                                        <button class="code-tab-button" data-lang="python">Python</button>
                                        <button class="code-tab-button" data-lang="cpp">C++</button>
                                    </div>
                                    <div class="code-snippet-container">
                                        <pre class="code-snippet active" data-lang="java"><code class="language-java">public void dfs(Node start) {
    Stack<Node> stack = new Stack<>();
    Set<Node> visited = new HashSet<>();

    stack.push(start);

    while (!stack.isEmpty()) {
        Node current = stack.pop();
        if (!visited.contains(current)) {
            visited.add(current);
            // Process current node

            for (Node neighbor : current.getNeighbors()) {
                if (!visited.contains(neighbor)) {
                    stack.push(neighbor);
                }
            }
        }
    }
}</code></pre>
                                        <pre class="code-snippet" data-lang="python"><code class="language-python">def dfs(graph, start_node):
    visited = set()
    stack = [start_node]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            // Process node

            for neighbor in reversed(graph[node]): # To match recursive behavior
                if neighbor not in visited:
                    stack.append(neighbor)</code></pre>
                                        <pre class="code-snippet" data-lang="cpp"><code class="language-cpp">#include <iostream>
#include <vector>
#include <stack>
#include <set>

using namespace std;

void dfs(const vector<vector<int>>& adj, int start_node) {
    int n = adj.size();
    stack<int> s;
    set<int> visited;

    s.push(start_node);

    while (!s.empty()) {
        int u = s.top();
        s.pop();

        if (visited.find(u) == visited.end()) {
            visited.insert(u);
            // Process node u

            for (int v : adj[u]) {
                if (visited.find(v) == visited.end()) {
                    s.push(v);
                }
            }
        }
    }
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Particle Background -->
    <canvas id="particle-canvas"></canvas>

    <!-- Stats Modal -->
    <div id="stats-modal" class="modal-container">
        <div class="modal-content">
            <button class="modal-close-btn" id="stats-close-btn">&times;</button>
            <h2>Algorithm Complete!</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <i class="fas fa-ruler-horizontal"></i>
                    <p>Path Length</p>
                    <span id="stat-path-length">0</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-shoe-prints"></i>
                    <p>Nodes Visited</p>
                    <span id="stat-nodes-visited">0</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-stopwatch"></i>
                    <p>Time Taken</p>
                    <span id="stat-time-taken">0s</span>
                </div>
                <div class="stat-item">
                    <i class="fas fa-chart-line"></i>
                    <p>Efficiency</p>
                    <span id="stat-efficiency">0%</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="sounds.js"></script>
    <script src="app.js"></script>
    <script src="utils.js"></script>
    <script src="visualizer.js"></script>
    <script src="particles.js"></script>
</body>
</html>
